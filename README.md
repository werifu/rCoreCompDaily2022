## 简介
参加2022 rCore Comp的学习日志

## 目录

#### 7.05

* 一边阅读[《Rust语言圣经》](https://course.rs/about-book.html) 一边做rustlings（接近40道）
* 一些新的收获：
  * match 模式匹配是一个非常有魅力的设定，能像switch一样区分出各种各样可预见的值，还能进行匹配的赋值，在语义上有极其强大的表达能力；此外，rust中区分表达式和语句使得match这个行为本身也能有一个值，像是三目运算符的加强版
  * 实际上模式匹配无处不在，解构也是一种匹配，在js里非常常见而且优雅，@绑定给match的项增加了表达能力（可以用于进一步约束）
  * [给enum添加方法，如何匹配自身？](https://stackoverflow.com/questions/33925232/how-to-match-over-self-in-an-enum) match *self
  * rust在泛型&特征方面提供了巨多语法糖，<T: SomeTrait>、where、impl SomeTrait，看上去很方便，不过怀疑在实践中会带来一定的混乱。
  * 特征对象其实就是一个实现了某些trait的对象，但是编译期无法确定具体对象类型，因此只能在运行时创建，使用& / Box\<dyn Trait\>用智能指针来创建（特征对象的动态分发）

#### 7.06

* 一边阅读圣经一边做rustlings，进度53/84

  * 在error6卡到了一下，对map_err的使用有了更深的理解，rust的数据处理方式感觉跟js真的很像

* 收获：

  * vector的引用：

    对一个元素有不可变引用后，不能拥有该vector的可变引用（即不能同时push又同时修改其中某个元素），虽然看起来风牛马不相及，安全问题在哪？

    > 原因在于：数组的大小是可变的，当旧数组的大小不够用时，Rust 会重新分配一块更大的内存空间，然后把旧数组拷贝过来。这种情况下，之前的引用显然会指向一块无效的内存，这非常 rusty —— 对用户进行严格的教育

    这个点确实没想到

* to_string, to_owned, into()的区别

* 语法糖?会让Err的情况下一直返回错误，而main返回()，所以main里不能用func()?吗
  ：错误的，main也可以返回Result

  * 比Go文明许多的设计，代替了if err != nil return err这样的句子，让链式调用更方便

  

#### 7.07

* 一边阅读圣经一边做rustlings，进度69/84，开始难起来了
* 包crate和项目package
  * package是一个项目工程，crate是一个编译单元
* 限制可见性pub (in crate::a)
  * 原本子mod可以访问父mod的private项，但父不可以，使用限制可见性可以有一定自由度地控制父访问子private的权限
* 自定义实现fmt::Display
* 生命周期
  * 生命周期标注并不会改变任何引用的实际作用域，帮助推导（隐形=>显性
  * 生命周期消除三原则
    * **每一个引用参数都会获得独自的生命周期**
    * **若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期**，也就是所有返回值的生命周期都等于该输入生命周期
    * **若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期**
  * 不符合三原则就得手标，其实本质上都有标，只是编译器进行消除来减少手写

#### 7.08

* rustlings完成！
* 迭代器的 collect方法有很丰富的功能，手动指定可以返回想要的数组类型
* 线程屏障 barrier让多个线程都执行到某个点后，才继续一起往后执行
* RefCell 与内部可变性，可以解决struct部分字段可改的需求（可改字段使用RefCell<>包裹）
* 宏的写法，功能很强大，但是不好写，需要多琢磨

#### 7.09

* 做了五道rust quiz，真难啊，，，几道看了答案。答案附[另一个文档上](../RustQuiz.md)

  * #1：注意甄别||闭包跟逻辑或
  * #16：rust没有自增/自减运算，但是可以`--x`表示负负得正的x
  * #21：
    * rust有Break-with-value这种东西，可以给loop statement提供一个值
    * `(return)`这个表达式的值是`()`
  * #26：迭代器的lazy特性，不被使用不会执行map里的闭包
  * #27：trait有`trait Trait1: Trait2 {}`的写法，但表示一种约束constraint，而不是继承，二者之间实际上没啥关系，因此在两个traits中有同样的方法名并不会造成混淆

* 看了《计算机组成与设计：软硬件接口RV》的第一章，感觉没太多新接收的概念，大多以前有了解，讲了计算机硬件发展的历程，然后和评判计算机性能的指标。有意思的是八个伟大的思想：

  1. 面向摩尔定律的设计 设计芯片的时候要考虑未来工艺，需要超前点

  2. 使用抽象简化设计

  3. 加速经常性事件

  4. 通过并行提高性能

  5. 通过流水线提高性能

  6. 通过预测提高性能

  7. 存储层次 Memory Hierarchy

  8. 通过冗余提高可靠性

